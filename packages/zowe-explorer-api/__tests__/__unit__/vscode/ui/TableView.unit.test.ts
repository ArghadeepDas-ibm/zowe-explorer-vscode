import { join } from "path";
import { Table } from "../../../../src";
import { env, EventEmitter, Uri, window } from "vscode";
import * as crypto from "crypto";

function createGlobalMocks() {
    const mockPanel = {
        onDidDispose: (_fn) => {},
        webview: { asWebviewUri: (uri) => uri.toString(), onDidReceiveMessage: (_fn) => {}, postMessage: (_message, _origin, _transfer) => {} },
    };
    // Mock `vscode.window.createWebviewPanel` to return a usable panel object
    const createWebviewPanelMock = jest.spyOn(window, "createWebviewPanel").mockReturnValueOnce(mockPanel as any);

    return {
        createWebviewPanelMock,
        context: {
            extensionPath: "/a/b/c/zowe-explorer",
            extension: {
                id: "Zowe.vscode-extension-for-zowe",
            },
        },
    };
}

// Table.View unit tests
describe("Table.View", () => {
    describe("getUris", () => {
        it("returns the URIs from the WebView base class", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            const buildPath = join(globalMocks.context.extensionPath, "src", "webviews");
            const scriptPath = join(buildPath, "dist", "table-view", "table-view.js");
            expect(view.getUris()).toStrictEqual({
                disk: {
                    build: Uri.parse(buildPath),
                    script: Uri.parse(scriptPath),
                    css: undefined,
                },
                resource: {
                    build: buildPath,
                    script: scriptPath,
                    css: undefined,
                },
            });
        });
    });

    describe("getHtml", () => {
        it("returns the HTML content generated by the WebView base class", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            expect(view.getHtml()).toStrictEqual(view.panel.webview.html);
        });
    });

    describe("updateWebview", () => {
        it("calls postMessage on the panel and sends the data to the webview", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);

            // case 1: Post message was not successful; updateWebview returns false
            const postMessageMock = jest.spyOn(view.panel.webview, "postMessage").mockResolvedValueOnce(false);
            await expect((view as any).updateWebview()).resolves.toBe(false);
            expect(postMessageMock).toHaveBeenCalledWith({
                command: "ondatachanged",
                data: { title: "Table" },
            });

            // case 2: Post message was successful; updateWebview returns true and event is fired
            const emitterFireMock = jest.spyOn(EventEmitter.prototype, "fire");
            postMessageMock.mockResolvedValueOnce(true);
            await expect((view as any).updateWebview()).resolves.toBe(true);
            expect(postMessageMock).toHaveBeenCalledWith({
                command: "ondatachanged",
                data: { title: "Table" },
            });
            expect(emitterFireMock).toHaveBeenCalledWith({ title: "Table" });
            postMessageMock.mockRestore();
        });
    });

    describe("getId", () => {
        it("returns a valid ID for the table view", () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            const randomUuidMock = jest.spyOn(crypto, "randomUUID").mockReturnValueOnce("foo-bar-baz-qux-quux");
            expect(view.getId()).toBe("Table-foo##Zowe.vscode-extension-for-zowe");
            expect(randomUuidMock).toHaveBeenCalled();
        });
    });

    describe("setTitle", () => {
        const updateWebviewMock = jest.spyOn((Table.View as any).prototype, "updateWebview");

        it("returns false if it was unable to send the new title", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            updateWebviewMock.mockResolvedValueOnce(false);
            await expect(view.setTitle("Unstable Table of Cables")).resolves.toBe(false);
        });

        it("returns true if it successfully sent the new title", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            updateWebviewMock.mockResolvedValueOnce(true);
            await expect(view.setTitle("Unstable Table of Cables")).resolves.toBe(true);
            expect((view as any).data.title).toBe("Unstable Table of Cables");
        });
    });

    describe("setOptions", () => {
        const updateWebviewMock = jest.spyOn((Table.View as any).prototype, "updateWebview");

        it("returns false if it was unable to send the new options", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            updateWebviewMock.mockResolvedValueOnce(false);
            await expect(
                view.setOptions({
                    debug: true,
                    pagination: false,
                })
            ).resolves.toBe(false);
        });

        it("returns true if it successfully sent the new options", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            updateWebviewMock.mockResolvedValueOnce(true);
            await expect(
                view.setOptions({
                    debug: true,
                    pagination: false,
                })
            ).resolves.toBe(true);
            expect((view as any).data.debug).toBe(true);
            expect((view as any).data.pagination).toBe(false);
        });
    });

    describe("setColumns", () => {
        const updateWebviewMock = jest.spyOn((Table.View as any).prototype, "updateWebview");

        it("returns false if it was unable to send the new columns", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table" } as any);
            updateWebviewMock.mockResolvedValueOnce(false);
            await expect(view.setColumns([{ field: "apple" }, { field: "banana" }, { field: "orange" }])).resolves.toBe(false);
        });

        it("returns true if it successfully sent the new options", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Stable Table of Cables" } as any);
            updateWebviewMock.mockResolvedValueOnce(true);
            const cols = [
                { field: "apple", valueFormatter: (data: { value: Table.CellData }) => `${data.value.toString()} apples` },
                { field: "banana", comparator: (valueA, valueB, nodeA, nodeB, isDescending) => -1, colSpan: (params) => 2 },
                { field: "orange", rowSpan: (params) => 2 },
            ];
            await expect(view.setColumns(cols)).resolves.toBe(true);
            expect((view as any).data.columns).toStrictEqual(
                cols.map((col) => ({
                    ...col,
                    colSpan: col.colSpan?.toString(),
                    comparator: col.comparator?.toString(),
                    rowSpan: col.rowSpan?.toString(),
                    valueFormatter: col.valueFormatter?.toString(),
                }))
            );
        });
    });

    describe("onMessageReceived", () => {
        it("fires the onTableDisplayChanged event when handling the 'ondisplaychanged' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ changing display" } as any);
            const onTableDisplayChangedFireMock = jest.spyOn((view as any).onTableDisplayChangedEmitter, "fire");
            const tableData = { rows: [{ a: 1, b: 1, c: 1 }] };
            await view.onMessageReceived({
                command: "ondisplaychanged",
                data: tableData,
            });
            expect(onTableDisplayChangedFireMock).toHaveBeenCalledWith(tableData);
        });

        it("calls updateWebview when handling the 'ready' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ changing display" } as any);
            const updateWebviewMock = jest.spyOn(view as any, "updateWebview").mockImplementation();
            await view.onMessageReceived({
                command: "ready",
            });
            expect(updateWebviewMock).toHaveBeenCalled();
            updateWebviewMock.mockRestore();
        });

        it("calls vscode.env.clipboard.writeText when handling the 'copy' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ copy" } as any);
            const writeTextMock = jest.spyOn(env.clipboard, "writeText").mockImplementation();
            const mockWebviewMsg = {
                command: "copy",
                data: { row: { a: 1, b: 1, c: 1 } },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).toHaveBeenCalledWith(JSON.stringify(mockWebviewMsg.data.row));
            writeTextMock.mockRestore();
        });

        it("calls vscode.env.clipboard.writeText when handling the 'copy-cell' command", async () => {
            const globalMocks = createGlobalMocks();
            const view = new Table.View(globalMocks.context as any, { title: "Table w/ copy-cell" } as any);
            const writeTextMock = jest.spyOn(env.clipboard, "writeText").mockImplementation();
            const mockWebviewMsg = {
                command: "copy-cell",
                data: { cell: 1, row: { a: 1, b: 1, c: 1 } },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).toHaveBeenCalledWith(mockWebviewMsg.data.cell);
            writeTextMock.mockRestore();
        });

        it("does nothing for a command that doesn't exist as a context option or row action", async () => {
            const globalMocks = createGlobalMocks();
            const data = {
                title: "Some table",
                rows: [{ a: 1, b: 1, c: 1 }],
                columns: [],
                contextOpts: {
                    all: [],
                },
                actions: {
                    all: [],
                },
            };
            const view = new Table.View(globalMocks.context as any, data);
            const updateWebviewMock = jest.spyOn(view as any, "updateWebview");
            const writeTextMock = jest.spyOn(env.clipboard, "writeText");
            const mockWebviewMsg = {
                command: "nonexistent-action",
                data: { row: data.rows[0] },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).not.toHaveBeenCalled();
            expect(updateWebviewMock).not.toHaveBeenCalled();
        });

        it("runs the callback for an action that exists", async () => {
            const globalMocks = createGlobalMocks();
            const callbackMock = jest.fn();
            const data = {
                title: "Some table",
                rows: [{ a: 1, b: 1, c: 1 }],
                columns: [],
                contextOpts: {
                    all: [],
                },
                actions: {
                    all: [
                        {
                            title: "Some action",
                            command: "some-action",
                            callback: {
                                typ: "cell",
                                fn: (_cell: Table.CellData) => {
                                    callbackMock();
                                },
                            },
                        } as Table.Action,
                    ],
                },
            };
            const view = new Table.View(globalMocks.context as any, data);
            const updateWebviewMock = jest.spyOn(view as any, "updateWebview");
            const writeTextMock = jest.spyOn(env.clipboard, "writeText");
            const mockWebviewMsg = {
                command: "some-action",
                data: { cell: data.rows[0].a, row: data.rows[0] },
            };
            await view.onMessageReceived(mockWebviewMsg);
            expect(writeTextMock).not.toHaveBeenCalled();
            expect(updateWebviewMock).not.toHaveBeenCalled();
            expect(callbackMock).toHaveBeenCalled();
        });
    });
});

// Table.Instance unit tests
